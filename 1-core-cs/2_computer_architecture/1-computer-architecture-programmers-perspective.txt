

1. A Tour of Computer Systems

----------------------------------------------------------
------------------------- PART 1 -------------------------
------------ Program Structure and Execution -------------
----------------------------------------------------------

2. Representing and Manipulating Information
3. Machine-Level Representation of Programs 
4. Processor Architecture 
5. Optimizing Program Performance 
6. The Memory Hierarchy 

----------------------------------------------------------
------------------------- PART 2 -------------------------
------------- Running Programs on a System  --------------
----------------------------------------------------------

7. Linking 
8. Exceptional Control Flow 
9. Virtual Memory 

----------------------------------------------------------
------------------------- PART 3 -------------------------
----- Interaction and Communication between Programs  ----
----------------------------------------------------------

10. System-Level I/O
11. Network Programming 
12. Concurrent Programming 





----------------------------------------------------------
1. A Tour of Computer Systems
----------------------------------------------------------

  Information Is Bits + Context
    chars => ASCII => bytes

  Programs Are Translated by Other Programs into Different Forms
    --- compilation system
    preprocessor - modifies .c file according to directives starting with '#'.
    compiler     - translates .c to .s containing assembly-language.
    assembler    - translates .s to .o containing machine-level instructions.
    linker       - link .o file with other precompiled .o files.
    
  It Pays to Understand How Compilation Systems Work

  Processors Read and Interpret Instructions Stored in Memory
    --- hardware organization of a system
    buses       - transfers fixed-size chunks of bytes known as 'words'.
    I/O devices - connected to I/O bus by either controller or adapter.
    main memory - a collection of dynamic random access memory (DRAM).
    processor   - copies data (pointed by PC) into register file from main memory, 
                  executes those instructions (if arithmetic, using APU) and
                  stores results in register file (a collection of word-sized
                  registers), which sends it to main memory.     

  Caches Matter
    L1, L2 (and L3) - increasingly large and decreasingly fast. Have the same 
    performance characteristics as registers but considerable larger. 
    Implemented with static random access memory (SRAM).

    exploiting cache memories correctly can improve performance by an order of
    magnitude.

  Storage Devices Form a Hierarchy
    L0 (registers) <=> L1 (SRAM) <=> L2 (SRAM) <=> L3 (SRAM) <=> L4 (DRAM) <=>
    L5 (local disks) <=> L6 (distributed file systems, web servers).

    each level serves as a cache for the level below.

  The Operating System Manages the Hardware
    ----------------------------------------
    |         Application programs          |
    ----------------------------------------|
    |                 OS                    |
    ----------------------------------------|
    | Processor | Main memory | I/O devices |
    -----------------------------------------
    |           |             |             | 
    |           |             ---- Files ---|
    |           |                           |
    |           ------- Virtual memory -----|
    |                                       |
     --------------- Processes -------------

    process is the OS's abstraction for running a program. each process has its
    own context (state) and is managed by the OS's kernel. can consist of
    multiple execution units (threads).

    virtual memory
      kernel virtual memory   ↑
      stack                   ↑
      shared libraries        ↑ increasing address index 
      heap                    ↑
      program code and data   ↑

    file - a sequence of bytes (every device is modeled as a file)

  Systems Communicate with Other Systems Using Networks

  Important Themes
    parallelism 
      thread-level concurrency
        multiple programs at the same time - concurrency
        multiple threads per single program - thread-level concurrency 

      instruction-level parallelism
        executing multiple instructions at the same time

      single-instruciton, multiple-data (SIMD) parallelism
        single instruction causing mutliple operations to be performated at the
        same time

    the importance of abstractions in computer systems
      on processor side
        instruction set architecture - one instruction set for all types of
        processor implementations

      on operating system side
        files, virtual memory, processes

  Summary


----------------------------------------------------------
2. Representing and Manipulating Information
----------------------------------------------------------
The basic definitions of the encodings, derivation such
properties as the range of representable numbers, their bit-level
representations, and the properties of the arithmetic operations.

  The three most important representations of numbers. 
    Unsigned (0 and up)
    Two's-complement (most common way to represent signed ints (- & +))
    Floating point (real numbers)

  Information Storage
    binary (machine) - hexadecimal (easy to communicate) - decimal (humans)

    word size (w-bit) => virtual address space (0 - ([2^w] - 1)); for example,
    32-bit word size limits the vas to 4GB, while 64-bit leads to a vas of 16
    exabytes. 
      -------------------------------------------------
          C declaration                     Bytes
      ------------------------------    ---------------
      Signed          Unsigned          32-bit  64-bit
      -------------------------------------------------
      [signed] char   unsigned char       1       1
      short           unsigned short      2       2
      int             unsigned            4       4
      long            unsigned long       4       8
      int32_t         uint32_t            4       4
      int64_t         uint64_t            8       8
      char*                               4       8
      float                               4       4
      double                              8       8
      -------------------------------------------------
      * Using fixed-size integer types (intN_t where N = 8 16 32 64) is the
      best way for programmers to have close control over data
      representations across different machines and compilers.

      a multi-byte object is stored as a contiguous sequence of bytes, with the
      address of the object given by the smallest address of the bytes used.

      Boolean Algebra
      -----------------------------------------------
        Operation     Math      CS      Sets
      -----------------------------------------------
        NOT           ¬         ~       complement
        AND           ∧         &       intersection 
        OR            ∨         |       union
        NOR           ⊕         ^
      -----------------------------------------------

        0110      0110      0110
      & 1100    | 1100    ^ 1100    ~ 1100
        ----      ----      ----      ----
        0100      1110      1010      0011

      One useful application of bit vectors is to represent finite sets. We can
      encode any subsetA ⊆ {0, 1, . . . , w − 1} with a bit vector [aw−1, . . . ,
      a1, a0], where ai = 1 if and only if i ∈ A. For example, bit vector a =
      [01101001] encodes the set A = {0, 3, 5, 6}.


      shift operations
      ----------------------------------------------------------------
      operation             Value 1      Value 2
      ----------------------------------------------------------------
      Argument x            [0110 0011]  [1001 0101]
      x << 4                [0011 0000]  [0101 0000]
      x >> 4 (logical)      [0000 0110]  [0000 1001]
      x >> 4 (arithmetic)   [0000 0110]  [1111 1001]
      ----------------------------------------------------------------

  Integer Representation
      Unsigned encodings
        [1011] => 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 11
        [1111] => 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0 = 15

      Two's complement encodings (signed)
        [1011] => -1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = -5
        [1111] => -1*2^3 + 1*2^2 + 1*2^1 + 1*2^0 = -1 
        * most significant bit has negative weight.

      Signed <=> Unsigned (casting)
        the effect of casting is to keep the bit values identical but change
        how these bits are interpreted.

      Expanding the bit representation of a number
        for unsigned, add necessary # of zeros to the left
        for signed, add necessary # of sign-bits to the left

        * One point worth making is that the relative order of conversion from
        one data size to another and between unsigned and signed can affect the
        behavior of a program. 

      Truncating Numbers
        going from w-bit to k-bit means we drop the high-order (w - k) bits. In
        decimal terms, this means

        -- positive truncation (positive overflow)
        d_new = d_old - (2^k). (- could be replaced with mod)

        -- negative truncation (negative overflow)
        d_new = d_old + (2^k).

      One way to avoid int bugs is to never use unsigned numbers except in
      packing word with flags, addresses in systems programming and
      implementing math packages.

  Integer Arithmetic
    Unsigned
      addition:         normal case vs overflow (truncate the result)
      negation:         x = 0 ? x : 2^w - x
      multiplication:   normal vs overflow (truncate the result)

    Two's complement 
      addition:         negative overflow vs normal vs positive overflow
      negation:         x = MIN ? MIN : -x
      multiplication:   negative overflow vs normal vs positive overflow

    Multiplying by Constant

    Dividing by Powers of 2
      Integer division always rounds toward zero. That is, it should round down
      a positive result and round up a negative one. 

  Floating Point
    Value       (-1)^s * M * 2^E
    Binary      [s] [exp] [frac]

    ---------------------------------------------------------
     Part             Meaning
    ---------         ---------------------------------------
      s               sign bit (1 - neg; 0 - pos)

    ---------------------------------------------------------
      exp [E]         E = e - Bias
                        e       k-bit unsigned number 
                        Bias    2^(k-1) - 1

    ---------------------------------------------------------
      frac [M]        fractional value 

            -----------------------------------------------------------------------------
            Exp         Case            Binary representation             Value
            ------      ------------    -------------------------         ---------------
                        Normal          M = 1.f(n-1)...f(1)f(0)           1<=M<2
            -----------------------------------------------------------------------------
            0s          Denormalized    M = 0.f(n-1)...f(1)f(0)           0<=M<1
            -----------------------------------------------------------------------------
            1s          Special*        M = all zeroes || nonzero         infinity || NaN
            -----------------------------------------------------------------------------

    Rounding
      ----------------------------------------------------------------
        Mode                        1.40   1.60   1.50   2.50   –1.50
      ----------------------------------------------------------------
        Round-to-even (default)       1      2      2      2      –2
        Round-toward-zero             1      1      1      2      –1
        Round-down                    1      1      1      2      –2
        Round-up                      2      2      2      3      –1
      ----------------------------------------------------------------

  Summary





































